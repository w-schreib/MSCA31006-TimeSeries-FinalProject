---
title: "MSCA 31006 Time Series - Final Project - Holt Winters"
author: "Anna Auersperg"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# load packages
packages <- c("tidyverse","reshape2","xts","forecast","lubridate","tseries","fpp","tsibble","feasts","TSA","naniar","lubridate")
suppressPackageStartupMessages(lapply(packages, require, character.only = TRUE))

```

# Import and process data

```{r}
# import data
raw.df <- read.csv("city_temperature.csv")

# remove observations with year = 200, 201 or 2020 (only partial data), Day = 0 
wip.df <- raw.df %>% 
  filter(!Year %in% (200:201)) %>%
  filter(Day != 0)

# date data type
wip.df <- wip.df %>%
  mutate(Date = as.Date(with(wip.df,paste(Year,Month,Day,sep="-")),
                        "%Y-%m-%d")) %>%
  select(-c("Month","Day","Year"))

# number of days between the start and end date (inclusive)
n_days <- max(wip.df$Date) - min(wip.df$Date) + 1
```

Subset US cities

```{r}
# list of US cities of interest
CitiesOfInterest <- c("Chicago",
                      "Anchorage",
                      "Denver",
                      "Indianapolis",
                      "Kansas City",
                      "Las Vegas",
                      "Los Angeles",
                      "Miami Beach",
                      "Minneapolis St. Paul",
                      "New York City",
                      "Phoenix",
                      "Raleigh Durham",
                      "San Antonio")

# subset US cities of interest 
df.usa <- wip.df %>% dplyr::filter((Country=="US") 
                                     & (City %in% CitiesOfInterest) 
                                     & (State!="Additional Territories")) %>%
  select(-c("Region", "Country", "State")) # drop redundant columns

# reshape data set, one column per city
df_melt <- melt(df.usa, id.vars = c("Date","City"))
df.usa2 <- dcast(df_melt, Date ~ City)

# update values where `AvgTemperature` = -99 by forward filling 
df.usa2 <- df.usa2 %>% naniar::replace_with_na_all(condition = ~.x == -99)
df.usa2 <- na.locf(na.locf(df.usa2), fromLast = FALSE)
```

## Univariate Time Series: Daily, Weekly, Monthly Avg Temp in Chicago

*Create Test and Train Splits*

-   Train : 1995-01-01 - 2019-12-31
-   Test : 2020-01-01 - 2020-05-13

```{r}
train.test <- function(ts, year, split){
  if(split == 'train'){
    ts <- window(ts, end=c(year-1,12))
  }
  else{
    ts <- window(ts, start=c(year,1))
  }
  return(ts)
}
```

```{r}
# select Chicago
df <- df.usa2 %>% select(c("Date","Chicago")) %>% rename(AvgTemp = "Chicago")
```

### Function to generate time series of frequency specified

```{r}
generateTS <- function(freq){
  if(freq == 'week'){
     # group by week, use week start date 
      ts <- df %>% group_by(WeekStart = lubridate::floor_date(df$Date,unit="week")) %>%
        summarize(AvgTemp = mean(AvgTemp) %>% round(2)) %>% 
        select(-c("WeekStart")) %>% ts(start=c(1995,1), frequency=52)
  }
  if(freq == 'month'){
    ts <- df %>% group_by(YearMonth = as.yearmon(Date)) %>%
      summarize(AvgTemp = mean(AvgTemp) %>% round(2)) %>%   
      select(-c("YearMonth")) %>%
      ts(start=c(1995,1), frequency=12)
  }
  else{
    ts <-  df %>% select(-c("Date")) %>% ts(start=c(1995,1), frequency=365)
  }
  ts 
}
```

## Seasonal Decomposition

Separate 4 main components

1.  Observed

2.  Trend: Long-term trends in the data

3.  Seasonal: Repeated seasonal signal adder

4.  Random: Remaining components that cannot be attributed to seasonality or trend

```{r}
frequencies <- c("day","week","month")
lapply(frequencies, function(f){
  ts <- generateTS(f)
  decomp <- decompose(ts) 
  plot(decomp)
})
```

# Model
EvaluateModel <- function(pred){
  data.frame(Date = seq(from = as.Date("2020-01-01"), by = "week", length.out = length(test)),
                    Observed = as.numeric(test),
                    Predicted=pred$mean))
```{r}
train <- generateTS("week") %>% train.test(2020,"train")
test <- generateTS("week") %>% train.test(2020,"test")

results <-  data.frame(Date = seq(from = as.Date("2020-01-01"), by = "week", length.out = length(test)),
                    Observed = as.numeric(test))


EvaluateModel <- function(mod){
  pred <- forecast(mod, h=length(test), level=c(80,95))
  plot(pred, xlim=c(1995, 2020))
  lines(pred$fitted, lty=2, col="purple")
  
  resid <- pred$residuals
  acf(resid, lag.max=20, na.action=na.pass)
  Box.test(resid, lag=20, type="Ljung-Box")
  hist(resid)

  pred
}
```


## Holt Winters
```{r}
get.HW.params <- function(mod){
  data.frame(alpha = round(mod$alpha,5),
        beta = round(mod$beta,5),
        gamma = round(mod$gamma,5), row.names = mod$seasonal)
}
```

### Additive
```{r}
hw.1 <- HoltWinters(train)
hw.1.fc <- EvaluateModel(hw.1)
results$HW.Additive <- hw.1.fc$mean
```
### Multiplicative
```{r}
hw.2 <- HoltWinters(train, seasonal = "multiplicative")
hw.2.fc <- EvaluateModel(hw.2)
results$HW.Multiplicative <- hw.2.fc$mean
```

### Multiplicative vs. Additive
```{r}
hw.params <- rbind(get.HW.params(hw.1),get.HW.params(hw.2))
```

```{r}
plot(HW.additive$day)
lines(HW.additive$week$fitted, lty=2, col="blue")
lines(HW.additive$month$fitted, lty=2, col="red")
```

### Multiplicative

```{r}
HW.multiplicative <- setNames(lapply(frequencies,fit.HW,"multiplicative"),frequencies)
lapply(HW.multiplicative,checkresiduals)
```

#### Forecast Evaluation

Check there are no correlations between forecast errors

```{r}
lapply(HW.multiplicative, function(x){
  resid <- x$residuals
  #acf(resid, na.action = na.pass)
  checkresiduals(x)
})
```

```{r}
#inputs are a list of models 
Compare.Models <- function(mods){
  test <- generateTS("day") %>% train.test(2020,"test")
  df <- data.frame(Date = seq(from = as.Date("2020-01-01"), by = "day", length.out = length(test)),
                    Observed = as.numeric(test))
  df$Daily.Forecast <- na.locf(mods$day$mean)
  df$Weekly.Forecast <- na.locf(mods$week$mean)
  df$Monthly.Forecast <- na.approx(mods$month$mean)
  df
  #sapply(names(mods), function(x){
    #df$x <- na.locf(mods[[x]]$mean)
  #})
}
Compare.Models(HW.additive)
```

EvaluateModel \<- function(pred,freq){ test \<- generateTS(freq) %\>% train.test(2020,"test") data.frame(Date = seq(from = as.Date("2020-01-01"), by = freq, length.out = length(test)), Observed = as.numeric(test), Predicted=pred\$mean) }

A method that often provides accurate and robust forecasts for seasonal data is the Holt-Winters method with a damped trend and multiplicative seasonality
